# 写者优先
## 实现一（读－写－读：写者直接和多个读者竞争）
```c++
semaphore ReaderWriterMutex = 1;    //实现读写互斥
int Rcount = 0;                //读者数量
semaphore CountMutex = 1;    //读者修改计数互斥
semaphore WriterMutex = 1;  //用于实现写者优先

writer(){
    while(true){
        P(WriterMutex); //无写进程时进入
        P(ReaderWriterMutex); //互斥访问共享文件
        write;
        V(ReaderWriterMutex);  //释放共享文件
        V(WriterMutex); //恢复对共享文件的访问
    }

}

reader(){
    while(true){
        P(WriterMutex); //无写进程时进入
        P(CountMutex);
        if(Rcount == 0)        //当第一个读者进来时，阻塞写者
            P(ReaderWriterMutex);
        ++Rcount;
        V(CountMutex);
        V(WriterMutex);//恢复对共享文件的访问

        read;

        P(CountMutex);
        --Rcount;
        if(Rcount == 0)
            V(ReaderWriterMutex);    //当最后一个读者离开后，释放写者
        V(CountMutex);
    }
}
```
存在的问题：读写进程都在WriterMutex处竞争，只有一个进程能WriterMutex。
写进程饥饿，且没有优先于读进程。
**想象这种场景**：一个写进程获得了WriterMutex正在写文件，此时有10万个读者和１个写者A在等它释放。
* 问题１：写进程释放WriterMutex，随机唤醒等待进程，写进程几乎不可能被唤醒，发生饥饿。（没有实现写者优先）
* 问题2:在写者Ａ之后的读进程也参与竞争，有可能比写进程先被唤醒。写者没有任何优先可言。

结论：要避免写者和多个读者竞争WriterMutex，来达到优先唤醒写者的目的。
## 实现二（精准唤醒写进程）
```c++
Reader()  
{  
    while(1)  
    {  
        wait(outmutex)  
        wait(R)  
  
        wait(Rcount)  
        if(0 == readcount)  
            wait(fmutex)  
        readcount ++  
        wait(Rcount)  
  
        signal(R)  
        signal(outmutex)  
  
        ........  
        perform reading opreation  
        ........  
  
        wait(Rcount)  
        if(readcount == 0)  
            signal(fmutex)  
        signal(Rcount)  
    }  
}  
  
writer()  
{  
    while(1)  
    {  
        wait(Wcount)  
        if(writecount == 0)  
            wait(R)  
        writecount ++  
        signal(Wcount)  
  
        wait(fmutex)  
        ........  
        perform writing operation  
        ........  
        signal(fmtex)  
  
        wait(Wcount)  
        readcount--  
        if(readcount == 0)  
            signal(R)  
        signal(Wcount)  
  
    }  
}  
```
## 为什么需要outmutex
outmutex作用：将R等待进程数量控制在１个。防止海量读者进程与一个写者进程竞争R，达到读进程退出(W为空)临界精准唤醒写进程。
有outmutex，则最多一个写进程和一个读进程需求信号量Ｒ。
考虑场景：正在运行－fmutex池－R池－out池
（多个读）－空－（写，读）－（读、读、读、读、读...）


> 注：（多个读）－空（多个读者间不互斥，fmutex为空）


## 信号量实现中：阻塞进程被随机唤醒，更像在池里，而不是队列里。
进程退出临界区，释放信号量，此时唤醒进程是随机的。阻塞进程在池里而不是队列里。

## 如何实现进程A对进程B的优先级？
```C++
A(){
	wait(count_mutex);
    if(A_count==0)
    	wait(B);
    A_count++;
    signal(count_mutex);
    
	wait(fmutex);
    do something;
    signal(fmutex);
    
   	wait(count_mutex);
    A_count--;
    if(A_count==0)
    	signal(B);
    signal(count_mutex);
}

B(){
	wait(B);
    wait(fmutex);
    do something;
    signal(fmutex);
    signal(B);
   
}
```

## 经验
设计时从阻塞池抽象思考，分析代码时进程阻塞要具体到哪一行代码。
## 参考
[写者优先](https://love.junzimu.com/archives/2800)