## 什么是不可靠传输？
在不可靠信道上传输一组数据包会造成的问题：
* 丢失
* 乱序
* 重复
* bit错

一般常用的应用涉及的也就是TCP和UDP的选择，当然现实中还是使用TCP较多，因为大多数应用对数据的完整性、正确性有很高的要求，比如邮件服务/文件下载，但是对吞吐量和时间却没什么要求，而有些应用比如视频游戏/即时通讯对实时性的要求非常高，对数据丢失却是可以容忍的，视频聊天的时候清晰度不高或者出现小规模马赛克，略显失真不是什么大事，所以这个时候选用UDP协议更合适。

数据链路层是可靠的吗？
ip协议是不可靠的


## 既然数据链路层保证可靠传输，为什么TCP还要保证可靠传输？为什么每层都要差错检测？
问题1，既然，数据链路层采用了可靠的ARQ，可以重传，为什么在TCP又有可靠传输这一说呢？

答：我觉得TCP/IP是个通用的协议，它可能面对的“不同的数据链路层协议”，如HDLC,PPP等。但这些链路层协议未必都有实现ARQ协议（具体哪些没有我也不知道）。

      就算有链路层实现了连续ARQ协议，那链路层保证的可靠传输也是在“链路层”是可靠的。比如有传输如下：A =》B =》C =》D。如果链路层实现了连续ARQ协议，那至多也就保证中间的一个链路传输可靠。如A=>B是是可靠的。如果B是路由器的话，当B负载太大的话，也许它就在网络层把数据报丢掉了。

     这是， 对于A来说，它已经通过链路层可靠的将数据报发到B上，但当网络拥塞的时候，当这个数据包在B的等待队列是时候，有可能被B丢掉。这是就要靠传输层TCP的可靠传输了。

    总之，在链路层实现可靠（即采用ACK，重传）的办法，至多也就保证在“一段链路两个节点间可靠。”只有在传输层实现的可靠传输，才能保证“整条链路”的畅通。

问题2，这两个协议采用的滑动窗口有啥区别呢？

答：数据链路层的滑动窗口是“个数固定”的。而TCP的滑动窗口是“个数可变”的，可以由接收端设置WIN字段来修改。

—By 汤普金斯:以前自己也doubt过，为什么每层都要差错检测呢？其实就像上面答案说的一样，每一层的关注点不同，“端到端”的定义也不同，链路层是到路由器/交换机，而传输层是到接收端。

https://cloud.tencent.com/developer/article/1097487

## TCP如何保证可靠传输?
* 丢失-->
* 乱序-->编号
* 重复-->丢弃
* bit错-->校验和
* 流量控制
* 拥塞控制： 当网络拥塞时，减少数据的发送。
* 停止等待协议：保证数据可靠的被接收。发送方每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。接收方收到重复分组，丢弃分组，同时发确认。
* 超时重传：防止无限等待。

### 两种重传协议（优化了什么问题?怎么优化的?）
#### 自动重传请求ARQ 协议
当TCP发出一个段后，它启动一个超时计时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。
存在的问题：信道利用率低，效率低，每发一个必须等确认才能发下一个。发--等--发--等
![信道利用率](https://s1.ax1x.com/2020/05/19/Y54mqS.png)
信道利用率U = TD / (TD + RTT + TA)

Q:能不能优化等待时间？
A:提高并行性,维护一个滑动窗口，窗口内的分组连续发送不必逐个等待确认，等待了优化的等待时间。
#### 连续ARQ协议（结合滑动窗口协议）
这个协议会连续发送一组数据包，然后再等待这些数据包的ACK。
![滑动窗口协议](https://img-blog.csdn.net/20160313194734979)
* 累积确认
接收方：在收到一些分组后，不是逐个发送确认，而是对按序到达的最后一个分组发送确认。
发送方：如果收到了这个分组确认信息，则表示到这个分组为止的所有分组都已经正确接收到了。
* Go-back-N(回退N)


## 如何判断协议栈是否可靠？
A：关键是上层协议。ip不可靠，但是tcp/ip协议栈可靠。
发送方将上层数据打包交给下层
接受方将下层数据拆包交给上层


对于底层信道完全可靠的情况，只需要调用跟着基本法来，接到上层调用就做一系列操作（打包之类的）把数据发给下层，接收方对应层协议收到下层的调用就将数据做些操作然后发给上层协议，其他的就不需要考虑了。
我们已经在2.1提到，IP是不可靠的，但是可以依靠上层的协议（如TCP）使这个使用IP协议的通信变得可靠，这就好比记者在采访现场引导出了一些不符合积极向上的个人形象的言辞，但是没关系，上层还有编辑和其他审核人员，他们的专业技能可以保证把通讯稿写的符合基本法，那么宣传上就不会出现偏差。现在要解决的问题就是怎样在不可靠的网络层协议之上实现可靠的传输层协议。这里以在IP上实现的TCP为例。
